//  ---------------------------------------------------------------------------
//  <copyright file="TDSLogin7FedAuthOptionToken.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
//  </copyright>
//  ---------------------------------------------------------------------------

namespace TDSClient.TDS.Login7
{
    using System.IO;
	using System.Security.Cryptography;

	using TDSClient.TDS.PreLogin;
    using TDSClient.TDS.Utilities;
	
	/// <summary>
	/// The Federated authentication library type.
	/// </summary>
	public enum TDSFedAuthLibraryType : byte
	{
		IDCRL = 0x00,
		SECURITY_TOKEN = 0x01,
		ADAL = 0x02,
		UNSUPPORTED = 0x03,
	}

	/// <summary>
	/// The Federated authentication library type.
	/// </summary>
	public enum TDSFedAuthADALWorkflow : byte
	{
		UserPassword = 0x01,
		Integrated = 0X02,
		EMPTY = 0xff, // NULL 
	}

	/// <summary>
	/// Feature option token definition.
	/// </summary>
	public class TDSLogin7FedAuthOptionToken : TDSLogin7FeatureOptionToken
	{
		/// <summary>
		/// Nonce's length
		/// </summary>
		public static readonly uint NonceDataLength = 32;

		/// <summary>
		/// Signature's length
		/// </summary>
		public static readonly uint SignatureDataLength = 32;

		/// <summary>
		/// Feature type
		/// </summary>
		public override TDSFeatureID FeatureID { get { return TDSFeatureID.FederatedAuthentication; } }

		/// <summary>
		/// Federated Authentication option length
		/// </summary>
		public uint Length
		{
			get
			{
				return 6*sizeof(byte) // Option (library + echo)
					+ sizeof(byte);
			}
		}

		/// <summary>
		/// Federated authentication library.
		/// </summary>
		public TDSFedAuthLibraryType Library { get; private set; }

		/// <summary>
		/// FedAuthEcho: The intention of this flag is for the client to echo the serverâ€™s FEDAUTHREQUIRED prelogin option.
		/// </summary>
		public TdsPreLoginFedAuthRequiredOption Echo { get; private set; }

		/// <summary>
		/// Whether this protocol is requesting further information from server to perform authentication.
		/// </summary>
		public bool IsRequestingAuthenticationInfo { get; private set; }

		/// <summary>
		/// Federated authentication token generated by the specified federated authentication library.
		/// </summary>
		public byte[] Token { get; private set; }

		/// <summary>
		/// Federated authentication ADAL workflow type
		/// </summary>
		public TDSFedAuthADALWorkflow WorkflowType { get; private set; }

		/// <summary>
		/// The nonce provided by the server during prelogin exchange
		/// </summary>
		public byte[] Nonce { get; private set; }

		/// <summary>
		/// Channel binding token associated with the underlying SSL stream.
		/// </summary>
		public byte[] ChannelBingingToken { get; private set; }

		/// <summary>
		/// The HMAC-SHA-256 [RFC6234] of the server-specified nonce
		/// </summary>
		public byte[] Signature { get; private set; }

		/// <summary>
		/// FedAuth ADAL Workflow Type
		/// </summary>
		public TDSFedAuthADALWorkflow Workflow { get; private set; }

		/// <summary>
		/// Default constructor
		/// </summary>
		public TDSLogin7FedAuthOptionToken()
		{
		}

		/// <summary>
		/// Initialization Constructor.
		/// </summary>
		public TDSLogin7FedAuthOptionToken(TdsPreLoginFedAuthRequiredOption echo,
											TDSFedAuthLibraryType libraryType,
											byte[] token,
											byte[] nonce,
											byte[] channelBindingToken,
											bool fIncludeSignature,
											bool fRequestingFurtherInfo,
											TDSFedAuthADALWorkflow workflow)
			: this()
		{
			Echo = echo;
			Library = libraryType;
			Token = token;
			Nonce = nonce;
			WorkflowType = TDSFedAuthADALWorkflow.EMPTY;
			ChannelBingingToken = channelBindingToken;
			IsRequestingAuthenticationInfo = fRequestingFurtherInfo;

			if (libraryType == TDSFedAuthLibraryType.ADAL)
			{
				WorkflowType = workflow;
			}
			else
			{
				WorkflowType = TDSFedAuthADALWorkflow.EMPTY;
			}

			Workflow = WorkflowType;

			if (libraryType != TDSFedAuthLibraryType.SECURITY_TOKEN && fIncludeSignature)
			{
				Signature = new byte[SignatureDataLength];
				Signature = GenerateRandomBytes(32);
			}
		}

		/// <summary>
		/// Unpacking constructor
		/// </summary>		
		public TDSLogin7FedAuthOptionToken(MemoryStream source)
			: this()
		{
			Unpack(source);
		}

		/// <summary>
		/// Unpack the token
		/// </summary>
		/// <param name="source">Stream to inflate the token from</param>
		/// <returns>TRUE if inflation is complete</returns>
		public override bool Unpack(MemoryStream source)
		{
			Size = 0;
			uint optionDataLength = BigEndianUtilities.ReadUInt(source);
			Size += sizeof(uint);
			byte temp = (byte)source.ReadByte();
			Size += sizeof(byte);
			Echo = (TdsPreLoginFedAuthRequiredOption)(temp & 0x01);
			Library = (TDSFedAuthLibraryType)(temp >> 1);

			// When using the ADAL library, a FedAuthToken is never included, nor is its length included
			if (Library != TDSFedAuthLibraryType.ADAL)
			{
				uint fedauthTokenLen = BigEndianUtilities.ReadUInt(source);
				Size += sizeof(uint);

				if (fedauthTokenLen > 0)
				{
					Token = new byte[fedauthTokenLen];
					source.Read(Token, 0, (int)fedauthTokenLen);
					Size += fedauthTokenLen;
				}
			}
			else
			{
				Workflow = (TDSFedAuthADALWorkflow)source.ReadByte();
			}

			switch (Library)
			{
				case TDSFedAuthLibraryType.SECURITY_TOKEN:
					IsRequestingAuthenticationInfo = false;
					return ReadSecurityTokenLogin(source, optionDataLength);

				case TDSFedAuthLibraryType.ADAL:
					IsRequestingAuthenticationInfo = true;
					return true;

				default:
					return false;
			}
		}

		/// <summary>
		/// Pack the token
		/// </summary>
		/// <param name="destination">Stream to deflate token to</param>
		public override void Pack(MemoryStream destination)
		{
			destination.WriteByte((byte)FeatureID);

			uint optionDataLength = (uint)(sizeof(byte) // Options size (library and Echo)
									+ (WorkflowType == TDSFedAuthADALWorkflow.EMPTY ? 0 : sizeof(byte)) //ADAL workflow type
									+ ((Token == null && IsRequestingAuthenticationInfo) ? 0 : sizeof(uint)) // Fedauth token length
									+ (Token == null ? 0 : (uint)Token.Length) // Fedauth Token
									+ (Nonce == null ? 0 : NonceDataLength) // Nonce
									+ (ChannelBingingToken == null ? 0 : (uint)ChannelBingingToken.Length) // Channel binding
									+ (Signature == null ? 0 : SignatureDataLength)); // Signature

			LittleEndianUtilities.WriteUInt(destination, optionDataLength);

			byte temp = (byte)(((byte)Library << 1) | (byte)Echo);
			destination.WriteByte(temp);

			if (Library == TDSFedAuthLibraryType.ADAL && WorkflowType != TDSFedAuthADALWorkflow.EMPTY)
			{
				destination.WriteByte((byte)WorkflowType);
			}

			if (Token == null && !IsRequestingAuthenticationInfo)
			{
				BigEndianUtilities.WriteUInt(destination, 0);
			}
			else if (Token != null)
			{
				BigEndianUtilities.WriteUInt(destination, (uint)Token.Length);

				destination.Write(Token, 0, Token.Length);
			}

			if (Nonce != null)
			{
				destination.Write(Nonce, 0, Nonce.Length);
			}

			if (ChannelBingingToken != null)
			{
				destination.Write(ChannelBingingToken, 0, ChannelBingingToken.Length);
			}

			if (Signature != null)
			{
				destination.Write(Signature, 0, (int)SignatureDataLength);
			}
		}

		/// <summary>
		/// Read the stream for SecurityToken based login
		/// </summary>
		/// <param name="source">source</param>
		/// <param name="optionDataLength">option data length</param>
		/// <returns></returns>
		private bool ReadSecurityTokenLogin(Stream source, uint optionDataLength)
		{
			if (optionDataLength > Size)
			{
				Nonce = new byte[NonceDataLength];
				source.Read(Nonce, 0, (int)NonceDataLength);
				Size += NonceDataLength;
			}

			return true;
		}

		/// <summary>
		/// Generates random bytes
		/// </summary>
		/// <param name="count">The number of bytes to be generated.</param>
		/// <returns>Generated random bytes.</returns>
		private byte[] GenerateRandomBytes(int count)
		{
			byte[] randomBytes = new byte[count];

			using (RNGCryptoServiceProvider gen = new RNGCryptoServiceProvider())
			{
				gen.GetBytes(randomBytes);
			}

			return randomBytes;
		}
	}
}