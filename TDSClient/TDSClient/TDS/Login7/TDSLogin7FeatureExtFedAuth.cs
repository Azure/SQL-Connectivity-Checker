//  ---------------------------------------------------------------------------
//  <copyright file="TDSLogin7FeatureExtFedAuth.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
//  </copyright>
//  ---------------------------------------------------------------------------

namespace TDSClient.TDS.Login7
{
    using System;
    using System.IO;
    using TDSClient.TDS.Interfaces;
    using TDSClient.TDS.Utilities;

    /// <summary>
    /// Federated authentication library 
    /// </summary>
    public enum TDSFedAuthLibraryType : byte
	{
		LiveIDCompactToken = 0x00,
		SecurityToken = 0x01,
		ADAL = 0x02,
        Unsupported = 0x03
	}

    /// <summary>
    /// Federated authentication echo
    /// The intention of this flag is for the client to echo the server’s FEDAUTHREQUIRED pre-login 
    /// option so that the server can validate that the response was not tampered with.
    /// </summary>
    public enum TDSFedAuthEcho : byte 
    {
        EchoOff,
        EchoOn
    }

    /// <summary>
	/// ADAL workflow
	/// </summary>
	public enum TDSFedAuthADALWorkflow : byte
	{
		UsernamePassword = 0x01,
		Integrated = 0x02,
        Empty = 0xff
	}

    /// <summary>
    /// TDS Login7 Message Feature Ext Federated Authentication
    /// </summary>
#pragma warning disable CS0659 // Type overrides Object.Equals(object o) but does not override Object.GetHashCode()
    public class TDSLogin7FeatureExtFedAuth : TDSLogin7FeatureExt
#pragma warning restore CS0659 // Type overrides Object.Equals(object o) but does not override Object.GetHashCode()
    {


        // format:
        // bFedAuthLibrary       = 7BIT
        // fFedAuthEcho          = BIT
        // Workflow              = BYTE
        // Options               = bFedAuthLibrary
        //                         fFedAuthEcho
        //                         Workflow

		/// <summary>
		/// Feature type
		/// </summary>
        public override TDSFeatureID FeatureID { get { return TDSFeatureID.FederatedAuthentication; } }

		/// <summary>
		/// Federated Authentication option length
		/// </summary>
		public uint Length
		{
			get
			{
				return (uint)(sizeof(byte) // Option (library + echo)
					+ (WorkflowType == TDSFedAuthADALWorkflow.Empty ? 0 : (sizeof(byte)))
					+ sizeof(uint) // Token length variable
					+ (Token == null ? 0 : Token.Length)); // Actual token length
			}
		}

        /// <summary>
		/// Federated authentication library.
		/// </summary>
		public TDSFedAuthLibraryType Library { get; private set; }

		/// <summary>
		/// FedAuthEcho: The intention of this flag is for the client to echo the server’s FEDAUTHREQUIRED prelogin option.
		/// </summary>
		public TDSFedAuthEcho EchoFedAuthRequiredOption { get; private set; }

        /// <summary>
		/// Federated authentication ADAL workflow type
		/// </summary>
		public TDSFedAuthADALWorkflow WorkflowType { get; private set; }

        /// <summary>
		/// Whether this protocol is requesting further information from server to perform authentication.
		/// </summary>
		public bool IsRequestingAuthenticationInfo { get; private set; }

		/// <summary>
		/// Federated authentication token generated by the specified federated authentication library.
		/// </summary>
		public byte[] Token { get; private set; }

		/// <summary>
		/// FedAuth ADAL Workflow Type
		/// </summary>
		public TDSFedAuthADALWorkflow Workflow { get; private set; }

        /// <summary>
		/// Default constructor
		/// </summary>
		public TDSLogin7FeatureExtFedAuth()
		{
		}

        /// <summary>
		/// Initialization Constructor.
		/// </summary>
		public TDSLogin7FeatureExtFedAuth(TDSFedAuthLibraryType libraryType,
											TDSFedAuthEcho echo,
											TDSFedAuthADALWorkflow workflow)
			: this()
		{
			EchoFedAuthRequiredOption = echo;
			Library = libraryType;
			WorkflowType = TDSFedAuthADALWorkflow.Empty;

			if (libraryType == TDSFedAuthLibraryType.ADAL)
			{
				WorkflowType = workflow;
			}
			else
			{
				WorkflowType = TDSFedAuthADALWorkflow.Empty;
			}

			Workflow = WorkflowType;
		}

        /// <summary>
        /// Determines whether the specified object is equal to the current object.
        /// </summary>
        /// <param name="obj">The object to compare with the current object.</param>
        /// <returns>true if the specified object is equal to the current object; otherwise, false</returns>
        public override bool Equals(object obj)
        {
            return this.Equals(obj as TDSLogin7OptionFlags3);
        }

        /// <summary>
        /// Determines whether the specified object is equal to the current object.
        /// </summary>
        /// <param name="other">The object to compare with the current object.</param>
        /// <returns>true if the specified object is equal to the current object; otherwise, false</returns>
        public bool Equals(TDSLogin7OptionFlags3 other)
        {
            return true;
        }

        /// <summary>
        /// Used to pack IPackageable to a stream.
        /// </summary>
        /// <param name="stream">MemoryStream in which IPackageable is packet into.</param>
        public override void Pack(MemoryStream destination)
        {
            // Write option identifier
			destination.WriteByte((byte)FeatureID);

			// Calculate Feature Data length
			uint optionDataLength = (uint)(sizeof(byte) // Options size (library and Echo)
									+ (WorkflowType == TDSFedAuthADALWorkflow.Empty ? 0 : (sizeof(byte)))); //ADAL workflow type); // Fedauth Token

			// Write the cache length into the destination
			LittleEndianUtilities.WriteUInt(destination, optionDataLength);

			// Construct a byte from fedauthlibrary and fedauth echo.
			byte temp = (byte)((((byte)(Library) << 1) | (byte)(EchoFedAuthRequiredOption)));
			destination.WriteByte(temp);

			//write ADAL workflow type 
			if (Library == TDSFedAuthLibraryType.ADAL && WorkflowType != TDSFedAuthADALWorkflow.Empty)
			{
				destination.WriteByte((byte)WorkflowType);
			}

			// Write FederatedAuthenticationRequired token. // This will not be written for ADAL
			if (Token == null && !IsRequestingAuthenticationInfo)
			{
				// Write the length of the token is 0
				LittleEndianUtilities.WriteUInt(destination, 0);
			}
			else if (Token != null)
			{
				// Write the FederatedAuthenticationRequired token length.
				LittleEndianUtilities.WriteUInt(destination, (uint)Token.Length);

				// Write the token.
				destination.Write(Token, 0, Token.Length);
			}


        }

        /// <summary>
        /// Used to unpack IPackageable from a stream.
        /// </summary>
        /// <param name="stream">MemoryStream from which to unpack IPackageable.</param>
        /// <returns>Returns true if successful.</returns>
        public override bool Unpack(MemoryStream source) //inflate the token from the stream
        {
            // Reset inflation size
			unpackSize = 0;

			// We skip option identifier because it was read by construction factory
			// Read the length of the data for the option
			uint optionDataLength = LittleEndianUtilities.ReadUInt(source);

			// Update inflation offset
			unpackSize += sizeof(uint);

			// Read one byte for the flags
			byte temp = (byte)source.ReadByte();

			// Update inflation offset
			unpackSize += sizeof(byte);

			// Get the bit and set as a fedauth echo bit
			EchoFedAuthRequiredOption = (TDSFedAuthEcho)(temp & 0x01);

			// Get the remaining 7 bits and set as a library.
			Library = (TDSFedAuthLibraryType)(temp >> 1);

			// When using the ADAL library, a FedAuthToken is never included, nor is its length included
			if (Library != TDSFedAuthLibraryType.ADAL)
			{
			// Length of the FedAuthToken
			uint fedauthTokenLen = LittleEndianUtilities.ReadUInt(source);

			// Update inflation offset
			unpackSize += sizeof(uint);

			// Check if the fedauth token is in the login7
			if (fedauthTokenLen > 0)
			{
				// Allocate a container
				Token = new byte[fedauthTokenLen];

				// Read the Fedauth token.
				source.Read(Token, 0, (int)fedauthTokenLen);

				// Update inflation offset
				unpackSize += fedauthTokenLen;
			}
			}
			else
			{
				// Instead the workflow is included
				Workflow = (TDSFedAuthADALWorkflow)source.ReadByte();
			}

			switch (Library)
			{
				case TDSFedAuthLibraryType.ADAL:
					IsRequestingAuthenticationInfo = true;
					return true;

				default:
					return false;
			}
        }
    }
}